#include <Arduino.h>
#include <U8g2lib.h>
#include <SPI.h>

U8G2_SSD1327_WS_128X128_2_4W_SW_SPI u8g2(U8G2_R0, 13, 11, 10, 7, 8);

typedef struct Obstacle { // la struct definisce i dati necessari per disegnare su schermo un ostacolo
  int x, y;
} Obstacle;

int current_time, last_time, score, x_transition; // rispettivamente il tempo attuale, l'ultimo tempo registrato, il punteggio, e la transizione
float delta, py, accy; // rispettivamente il deltatime, la posizione del maiale sull'asse Y e l'accelerazione
char buffer[15]; // buffer ausiliario
bool is_transition; // flag di transizione
Obstacle obstacle; // ostacolo da superare
void (*draw)(); // puntatore a funzione utilizzato durante lo switch tra scene
void (*update)(); // puntatore a funzione utilizzato durante lo switch tra scene

// bitmap del maiale
static unsigned char pig_bits[] = {
  0x21, 0x72, 0xb4, 0xfe, 0x7f, 0x3f, 0x22, 0x22 };

// bitmap del logo
static unsigned char Flappy_Pig_Logo_bits[] = {
   0x00, 0xf0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0x1f, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x1f, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0xf8, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7e, 0x00, 0x00,
   0x00, 0xc0, 0x07, 0xfe, 0x73, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff,
   0x00, 0xe0, 0x01, 0xf0, 0x1f, 0xff, 0x73, 0x1c, 0x00, 0x00, 0x00, 0x00,
   0xf0, 0xff, 0x00, 0xf0, 0x07, 0xf8, 0x5f, 0xff, 0x73, 0x1c, 0x00, 0x00,
   0x00, 0x00, 0xf0, 0x07, 0x00, 0xf0, 0x0f, 0xfa, 0xdf, 0xe7, 0x73, 0x1c,
   0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0xf4, 0x1f, 0x3e, 0xdf, 0xe7,
   0x73, 0x1c, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xc3, 0x01, 0xfc, 0x1f, 0x3e,
   0xdf, 0xf7, 0x71, 0x1c, 0x7e, 0x00, 0x00, 0x00, 0xe0, 0xc7, 0x01, 0xf8,
   0x1e, 0xbe, 0xcf, 0xff, 0xe0, 0x0f, 0xc3, 0x38, 0x00, 0x00, 0xc0, 0xc7,
   0x01, 0xf8, 0x3e, 0xfe, 0x87, 0x7f, 0xc0, 0x8f, 0x81, 0x29, 0x00, 0x00,
   0xc0, 0xc7, 0x01, 0xf8, 0x3c, 0xfc, 0x83, 0x3f, 0x00, 0x8e, 0x00, 0x2d,
   0x00, 0x00, 0xc0, 0xc7, 0x03, 0xf8, 0x3e, 0xfc, 0x81, 0x1f, 0x00, 0x4e,
   0x0e, 0x25, 0x00, 0x00, 0xc0, 0xcf, 0x03, 0xf0, 0x7f, 0xfc, 0x80, 0x0f,
   0x00, 0x4e, 0x8a, 0x2d, 0x00, 0x00, 0xc0, 0xcf, 0x03, 0xf0, 0x7f, 0x7c,
   0x80, 0x0f, 0x00, 0x4e, 0x8a, 0x38, 0x00, 0x00, 0xc0, 0x8f, 0xe3, 0xf0,
   0x7f, 0x7c, 0x80, 0x0f, 0x00, 0x4e, 0x8e, 0x00, 0x00, 0x00, 0xc0, 0x8f,
   0xfb, 0xf1, 0x7d, 0x7c, 0x80, 0x0f, 0x00, 0x4f, 0xc0, 0x00, 0xe0, 0x03,
   0xc0, 0x8f, 0xff, 0xf1, 0xfd, 0x7c, 0x80, 0x0f, 0xc0, 0x4f, 0x70, 0x3c,
   0xb8, 0x02, 0xc0, 0x8f, 0xff, 0xf1, 0xf9, 0x7c, 0x80, 0x0f, 0xf0, 0x47,
   0x1c, 0x24, 0x0c, 0x06, 0xc0, 0x8f, 0xff, 0xf1, 0xf9, 0x7c, 0x80, 0x03,
   0xf8, 0x43, 0x04, 0x24, 0xf4, 0x04, 0xc0, 0x8f, 0x3f, 0xf0, 0x79, 0x1c,
   0x00, 0x00, 0xf8, 0x60, 0x04, 0x24, 0x96, 0x04, 0xc0, 0x8f, 0x07, 0x70,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x26, 0xf2, 0x0c, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x22, 0x02, 0x08,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x22,
   0x7e, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
   0x07, 0x3e, 0xc0, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0c, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x04, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x04,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x0e, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xf2, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x1e, 0x00 };

void pre_menu(){
  u8g2.firstPage();
  do {
    u8g2.drawXBM(10, 0, 108, 39, Flappy_Pig_Logo_bits);
    u8g2.setFont(u8g2_font_6x12_tr);
    u8g2.drawStr(18,50,"Press to start");
  } while ( u8g2.nextPage() );
}

void pre_game(){
  u8g2.setFont(u8g2_font_6x12_tr);
  obstacle = {128, 35 + rand()%50};
}

void pre_game_over(){
  // disegna su schermo Game over
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_ncenB14_tr);
    u8g2.drawStr(10,24,"Game Over!");
    sprintf(buffer, "Score: %d", score);
    u8g2.drawStr(10,44, buffer);
    u8g2.setFont(u8g2_font_6x12_tr);
    u8g2.drawStr(10,64,"Premi il pulsante");
    u8g2.drawStr(10,74,"per ricominciare");
  } while ( u8g2.nextPage() );
  // esegui il suono di game over
  tone(9,500,200);
  delay(200);
  tone(9,400,200);
  delay(200);
  tone(9,200,600);
  delay(600);
}

void menu_logic(){
  static float angle = 0.f;
  // se viene premuto il tasto allora inizia la transizione
  if(digitalRead(2) == HIGH) is_transition = true;
  
  // una volta finita la transizione inizia la partita
  if(is_transition && x_transition <= 10) {
    pre_game();
    update = &game_logic;
    draw = &game_graphics;
    return;
  }
  // altrimenti continua la transizione 
  else if(is_transition){
    x_transition -= 5 * delta;
  }

  // simula l'oscillazione del maiale 
  py += sin(angle) * 20.f * delta;
  angle += 0.5f;
  if(angle == 360.f) angle = 0.f;
}

void menu_graphics(){
  u8g2.customPage(7);
  do {
   u8g2.drawXBM(x_transition, py, 8, 8, pig_bits);
  } while ( u8g2.nextPage() );
}

void game_logic(){
  static bool point = false, last_press = false;
  // se avviene una collisione, allora disegna la scena di game over e passa alla funzione Game over
  if(py > 127 || py < 0 || (18 > obstacle.x && 10 < obstacle.x + 10 && (py <  obstacle.y - 24 || py+8 > obstacle.y + 24))){
    pre_game_over();
    update = &game_over_logic;
    draw = NULL;
    point = false;
    last_press = false;
    return;
  }
  // incrementa lo score e fai partire il suono
  if(10 > obstacle.x + 5 && !point){
    point = true;
    score++;
    tone(9,1500,200);
  }
  // incrementa l'accelerazione di una costante
  accy += 100.f * delta;

  // se il tasto viene premuto, allora esegui il salto solo se non è attualmente già in esecuzione
  int dr = digitalRead(2);
  if (!last_press && dr == HIGH) {
    last_press = true;
    accy = -45.f;
  }
  else if(last_press && dr == LOW) {
    last_press = false;
  }

  // modifica la Y del maiale
  py += accy * delta;
  if(obstacle.x + 5 <= 0){
    obstacle = {128, 35 + rand()%50 };
    point = false;
  }
  else {
    int val = analogRead(A0);
    sprintf(buffer, "%d", val);
    Serial.println(buffer);
    obstacle.x -= map(val, 0, 1023, 1, 3) * 15.f * delta;
  }
}

void game_graphics(){
  // disegna su schermo
  u8g2.firstPage();
  do {
    sprintf(buffer, "%d", score);
    u8g2.drawStr(2,10,buffer);
    u8g2.drawXBM(10, py, 8, 8, pig_bits);
    u8g2.drawFrame(obstacle.x, -1, 10, obstacle.y - 25);
    u8g2.drawFrame(obstacle.x, obstacle.y + 25, 10, 128);
  } while ( u8g2.nextPage() );
}

void game_over_logic(){
  // se viene premuto il tasto, ripristina il gioco e comincia una nuova partita
  if(digitalRead(2) == HIGH){
    // calcola un nuovo ostacolo
    obstacle = {128, 35 + rand()%50 };
    py = 60;
    accy = 0;
    update = &game_logic;
    draw = &game_graphics;
    score = 0;
    return;
  }
}

void setup(void) {
  u8g2.begin();
  Serial.begin(9600);
  
  pinMode(2, INPUT);
  pinMode(4, INPUT);
  pinMode(9, OUTPUT);
  pinMode(A0, INPUT);

  current_time = 0, last_time = 0, score = 0, x_transition = 50;
  delta = 0, py = 80, accy = 0;
  is_transition = false;
  
  pre_menu();
  update = &menu_logic;
  draw = &menu_graphics;
}

void loop(void) {
  static float timer = 0;
  
  last_time = current_time;
  current_time = millis();
  delta = (current_time - last_time) / 1000.f;

  if(update != NULL) update();
  if(draw != NULL && timer > 0.0625f){
    timer = 0;
    draw();
  }
  timer += delta;
}
